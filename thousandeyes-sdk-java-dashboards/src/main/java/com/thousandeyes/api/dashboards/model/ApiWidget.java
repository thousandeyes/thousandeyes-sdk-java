/*
 * Dashboards API
 * Manage ThousandEyes Dashboards.
 *
 * The version of the OpenAPI document: 7.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.thousandeyes.api.dashboards.model;

import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.thousandeyes.api.dashboards.model.ApiAgentStatusWidget;
import com.thousandeyes.api.dashboards.model.ApiAggregateProperty;
import com.thousandeyes.api.dashboards.model.ApiAlertListWidget;
import com.thousandeyes.api.dashboards.model.ApiAlertListWidgetAllOfActiveWithin;
import com.thousandeyes.api.dashboards.model.ApiBoxAndWhiskersWidget;
import com.thousandeyes.api.dashboards.model.ApiColorGridWidget;
import com.thousandeyes.api.dashboards.model.ApiDuration;
import com.thousandeyes.api.dashboards.model.ApiGeoMapWidget;
import com.thousandeyes.api.dashboards.model.ApiGroupedBarchartWidget;
import com.thousandeyes.api.dashboards.model.ApiMultiMetricColumn;
import com.thousandeyes.api.dashboards.model.ApiMultiMetricTableWidget;
import com.thousandeyes.api.dashboards.model.ApiNumbersCard;
import com.thousandeyes.api.dashboards.model.ApiNumbersCardWidget;
import com.thousandeyes.api.dashboards.model.ApiPieChartWidget;
import com.thousandeyes.api.dashboards.model.ApiStackedAreaChartWidget;
import com.thousandeyes.api.dashboards.model.ApiStackedBarchartWidget;
import com.thousandeyes.api.dashboards.model.ApiTableWidget;
import com.thousandeyes.api.dashboards.model.ApiTestTableWidget;
import com.thousandeyes.api.dashboards.model.ApiTimeseriesWidget;
import com.thousandeyes.api.dashboards.model.ApiWidgetFilterApiTestTableFilterKey;
import com.thousandeyes.api.dashboards.model.ApiWidgetFixedYScalePrefix;
import com.thousandeyes.api.dashboards.model.ApiWidgetMeasure;
import com.thousandeyes.api.dashboards.model.DashboardMetric;
import com.thousandeyes.api.dashboards.model.DashboardMetricDirection;
import com.thousandeyes.api.dashboards.model.LegacyAgentWidgetShow;
import com.thousandeyes.api.dashboards.model.LegacyAgentWidgetType;
import com.thousandeyes.api.dashboards.model.LegacyAlertListAlertType;
import com.thousandeyes.api.dashboards.model.LegacyWidgetSortDirection;
import com.thousandeyes.api.dashboards.model.LegacyWidgetSortProperty;
import com.thousandeyes.api.dashboards.model.MetricGroup;
import com.thousandeyes.api.dashboards.model.SelfLinksLinks;
import com.thousandeyes.api.dashboards.model.TimeseriesDatasource;
import com.thousandeyes.api.dashboards.model.VisualMode;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import com.fasterxml.jackson.core.type.TypeReference;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import com.thousandeyes.api.serialization.JSON;
import com.thousandeyes.api.serialization.AbstractOpenApiSchema;

@jakarta.annotation.Generated(value = "com.thousandeyes.api.codegen.ThousandeyesJavaGenerator", date = "2024-04-22T10:43:50.839647+01:00[Europe/London]")
@JsonDeserialize(using = ApiWidget.ApiWidgetDeserializer.class)
@JsonSerialize(using = ApiWidget.ApiWidgetSerializer.class)
public class ApiWidget extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(ApiWidget.class.getName());

    public static class ApiWidgetSerializer extends StdSerializer<ApiWidget> {
        public ApiWidgetSerializer(Class<ApiWidget> t) {
            super(t);
        }

        public ApiWidgetSerializer() {
            this(null);
        }

        @Override
        public void serialize(ApiWidget value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
            jgen.writeObject(value.getActualInstance());
        }
    }

    public static class ApiWidgetDeserializer extends StdDeserializer<ApiWidget> {
        public ApiWidgetDeserializer() {
            this(ApiWidget.class);
        }

        public ApiWidgetDeserializer(Class<?> vc) {
            super(vc);
        }

        @Override
        public ApiWidget deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {
            JsonNode tree = jp.readValueAsTree();
            Object deserialized = null;
            boolean typeCoercion = ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS);
            int match = 0;
            JsonToken token = tree.traverse(jp.getCodec()).nextToken();
            // deserialize ApiAgentStatusWidget
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ApiAgentStatusWidget.class.equals(Integer.class) || ApiAgentStatusWidget.class.equals(Long.class) || ApiAgentStatusWidget.class.equals(Float.class) || ApiAgentStatusWidget.class.equals(Double.class) || ApiAgentStatusWidget.class.equals(Boolean.class) || ApiAgentStatusWidget.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ApiAgentStatusWidget.class.equals(Integer.class) || ApiAgentStatusWidget.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ApiAgentStatusWidget.class.equals(Float.class) || ApiAgentStatusWidget.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ApiAgentStatusWidget.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ApiAgentStatusWidget.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ApiAgentStatusWidget.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ApiAgentStatusWidget'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ApiAgentStatusWidget'", e);
            }

            // deserialize ApiAlertListWidget
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ApiAlertListWidget.class.equals(Integer.class) || ApiAlertListWidget.class.equals(Long.class) || ApiAlertListWidget.class.equals(Float.class) || ApiAlertListWidget.class.equals(Double.class) || ApiAlertListWidget.class.equals(Boolean.class) || ApiAlertListWidget.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ApiAlertListWidget.class.equals(Integer.class) || ApiAlertListWidget.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ApiAlertListWidget.class.equals(Float.class) || ApiAlertListWidget.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ApiAlertListWidget.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ApiAlertListWidget.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ApiAlertListWidget.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ApiAlertListWidget'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ApiAlertListWidget'", e);
            }

            // deserialize ApiBoxAndWhiskersWidget
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ApiBoxAndWhiskersWidget.class.equals(Integer.class) || ApiBoxAndWhiskersWidget.class.equals(Long.class) || ApiBoxAndWhiskersWidget.class.equals(Float.class) || ApiBoxAndWhiskersWidget.class.equals(Double.class) || ApiBoxAndWhiskersWidget.class.equals(Boolean.class) || ApiBoxAndWhiskersWidget.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ApiBoxAndWhiskersWidget.class.equals(Integer.class) || ApiBoxAndWhiskersWidget.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ApiBoxAndWhiskersWidget.class.equals(Float.class) || ApiBoxAndWhiskersWidget.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ApiBoxAndWhiskersWidget.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ApiBoxAndWhiskersWidget.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ApiBoxAndWhiskersWidget.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ApiBoxAndWhiskersWidget'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ApiBoxAndWhiskersWidget'", e);
            }

            // deserialize ApiColorGridWidget
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ApiColorGridWidget.class.equals(Integer.class) || ApiColorGridWidget.class.equals(Long.class) || ApiColorGridWidget.class.equals(Float.class) || ApiColorGridWidget.class.equals(Double.class) || ApiColorGridWidget.class.equals(Boolean.class) || ApiColorGridWidget.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ApiColorGridWidget.class.equals(Integer.class) || ApiColorGridWidget.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ApiColorGridWidget.class.equals(Float.class) || ApiColorGridWidget.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ApiColorGridWidget.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ApiColorGridWidget.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ApiColorGridWidget.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ApiColorGridWidget'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ApiColorGridWidget'", e);
            }

            // deserialize ApiGeoMapWidget
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ApiGeoMapWidget.class.equals(Integer.class) || ApiGeoMapWidget.class.equals(Long.class) || ApiGeoMapWidget.class.equals(Float.class) || ApiGeoMapWidget.class.equals(Double.class) || ApiGeoMapWidget.class.equals(Boolean.class) || ApiGeoMapWidget.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ApiGeoMapWidget.class.equals(Integer.class) || ApiGeoMapWidget.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ApiGeoMapWidget.class.equals(Float.class) || ApiGeoMapWidget.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ApiGeoMapWidget.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ApiGeoMapWidget.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ApiGeoMapWidget.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ApiGeoMapWidget'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ApiGeoMapWidget'", e);
            }

            // deserialize ApiGroupedBarchartWidget
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ApiGroupedBarchartWidget.class.equals(Integer.class) || ApiGroupedBarchartWidget.class.equals(Long.class) || ApiGroupedBarchartWidget.class.equals(Float.class) || ApiGroupedBarchartWidget.class.equals(Double.class) || ApiGroupedBarchartWidget.class.equals(Boolean.class) || ApiGroupedBarchartWidget.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ApiGroupedBarchartWidget.class.equals(Integer.class) || ApiGroupedBarchartWidget.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ApiGroupedBarchartWidget.class.equals(Float.class) || ApiGroupedBarchartWidget.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ApiGroupedBarchartWidget.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ApiGroupedBarchartWidget.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ApiGroupedBarchartWidget.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ApiGroupedBarchartWidget'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ApiGroupedBarchartWidget'", e);
            }

            // deserialize ApiMultiMetricTableWidget
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ApiMultiMetricTableWidget.class.equals(Integer.class) || ApiMultiMetricTableWidget.class.equals(Long.class) || ApiMultiMetricTableWidget.class.equals(Float.class) || ApiMultiMetricTableWidget.class.equals(Double.class) || ApiMultiMetricTableWidget.class.equals(Boolean.class) || ApiMultiMetricTableWidget.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ApiMultiMetricTableWidget.class.equals(Integer.class) || ApiMultiMetricTableWidget.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ApiMultiMetricTableWidget.class.equals(Float.class) || ApiMultiMetricTableWidget.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ApiMultiMetricTableWidget.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ApiMultiMetricTableWidget.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ApiMultiMetricTableWidget.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ApiMultiMetricTableWidget'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ApiMultiMetricTableWidget'", e);
            }

            // deserialize ApiNumbersCardWidget
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ApiNumbersCardWidget.class.equals(Integer.class) || ApiNumbersCardWidget.class.equals(Long.class) || ApiNumbersCardWidget.class.equals(Float.class) || ApiNumbersCardWidget.class.equals(Double.class) || ApiNumbersCardWidget.class.equals(Boolean.class) || ApiNumbersCardWidget.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ApiNumbersCardWidget.class.equals(Integer.class) || ApiNumbersCardWidget.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ApiNumbersCardWidget.class.equals(Float.class) || ApiNumbersCardWidget.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ApiNumbersCardWidget.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ApiNumbersCardWidget.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ApiNumbersCardWidget.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ApiNumbersCardWidget'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ApiNumbersCardWidget'", e);
            }

            // deserialize ApiPieChartWidget
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ApiPieChartWidget.class.equals(Integer.class) || ApiPieChartWidget.class.equals(Long.class) || ApiPieChartWidget.class.equals(Float.class) || ApiPieChartWidget.class.equals(Double.class) || ApiPieChartWidget.class.equals(Boolean.class) || ApiPieChartWidget.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ApiPieChartWidget.class.equals(Integer.class) || ApiPieChartWidget.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ApiPieChartWidget.class.equals(Float.class) || ApiPieChartWidget.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ApiPieChartWidget.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ApiPieChartWidget.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ApiPieChartWidget.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ApiPieChartWidget'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ApiPieChartWidget'", e);
            }

            // deserialize ApiStackedAreaChartWidget
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ApiStackedAreaChartWidget.class.equals(Integer.class) || ApiStackedAreaChartWidget.class.equals(Long.class) || ApiStackedAreaChartWidget.class.equals(Float.class) || ApiStackedAreaChartWidget.class.equals(Double.class) || ApiStackedAreaChartWidget.class.equals(Boolean.class) || ApiStackedAreaChartWidget.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ApiStackedAreaChartWidget.class.equals(Integer.class) || ApiStackedAreaChartWidget.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ApiStackedAreaChartWidget.class.equals(Float.class) || ApiStackedAreaChartWidget.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ApiStackedAreaChartWidget.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ApiStackedAreaChartWidget.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ApiStackedAreaChartWidget.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ApiStackedAreaChartWidget'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ApiStackedAreaChartWidget'", e);
            }

            // deserialize ApiStackedBarchartWidget
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ApiStackedBarchartWidget.class.equals(Integer.class) || ApiStackedBarchartWidget.class.equals(Long.class) || ApiStackedBarchartWidget.class.equals(Float.class) || ApiStackedBarchartWidget.class.equals(Double.class) || ApiStackedBarchartWidget.class.equals(Boolean.class) || ApiStackedBarchartWidget.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ApiStackedBarchartWidget.class.equals(Integer.class) || ApiStackedBarchartWidget.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ApiStackedBarchartWidget.class.equals(Float.class) || ApiStackedBarchartWidget.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ApiStackedBarchartWidget.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ApiStackedBarchartWidget.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ApiStackedBarchartWidget.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ApiStackedBarchartWidget'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ApiStackedBarchartWidget'", e);
            }

            // deserialize ApiTableWidget
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ApiTableWidget.class.equals(Integer.class) || ApiTableWidget.class.equals(Long.class) || ApiTableWidget.class.equals(Float.class) || ApiTableWidget.class.equals(Double.class) || ApiTableWidget.class.equals(Boolean.class) || ApiTableWidget.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ApiTableWidget.class.equals(Integer.class) || ApiTableWidget.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ApiTableWidget.class.equals(Float.class) || ApiTableWidget.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ApiTableWidget.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ApiTableWidget.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ApiTableWidget.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ApiTableWidget'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ApiTableWidget'", e);
            }

            // deserialize ApiTestTableWidget
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ApiTestTableWidget.class.equals(Integer.class) || ApiTestTableWidget.class.equals(Long.class) || ApiTestTableWidget.class.equals(Float.class) || ApiTestTableWidget.class.equals(Double.class) || ApiTestTableWidget.class.equals(Boolean.class) || ApiTestTableWidget.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ApiTestTableWidget.class.equals(Integer.class) || ApiTestTableWidget.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ApiTestTableWidget.class.equals(Float.class) || ApiTestTableWidget.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ApiTestTableWidget.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ApiTestTableWidget.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ApiTestTableWidget.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ApiTestTableWidget'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ApiTestTableWidget'", e);
            }

            // deserialize ApiTimeseriesWidget
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ApiTimeseriesWidget.class.equals(Integer.class) || ApiTimeseriesWidget.class.equals(Long.class) || ApiTimeseriesWidget.class.equals(Float.class) || ApiTimeseriesWidget.class.equals(Double.class) || ApiTimeseriesWidget.class.equals(Boolean.class) || ApiTimeseriesWidget.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ApiTimeseriesWidget.class.equals(Integer.class) || ApiTimeseriesWidget.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ApiTimeseriesWidget.class.equals(Float.class) || ApiTimeseriesWidget.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ApiTimeseriesWidget.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ApiTimeseriesWidget.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ApiTimeseriesWidget.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ApiTimeseriesWidget'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ApiTimeseriesWidget'", e);
            }

            if (match == 1) {
                ApiWidget ret = new ApiWidget();
                ret.setActualInstance(deserialized);
                return ret;
            }
            throw new IOException(String.format("Failed deserialization for ApiWidget: %d classes match result, expected 1", match));
        }

        /**
         * Handle deserialization of the 'null' value.
         */
        @Override
        public ApiWidget getNullValue(DeserializationContext ctxt) throws JsonMappingException {
            throw new JsonMappingException(ctxt.getParser(), "ApiWidget cannot be null");
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, Class<?>> schemas = new HashMap<>();

    public ApiWidget() {
        super("oneOf", Boolean.FALSE);
    }

    public ApiWidget(ApiAgentStatusWidget o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiWidget(ApiAlertListWidget o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiWidget(ApiBoxAndWhiskersWidget o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiWidget(ApiColorGridWidget o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiWidget(ApiGeoMapWidget o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiWidget(ApiGroupedBarchartWidget o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiWidget(ApiMultiMetricTableWidget o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiWidget(ApiNumbersCardWidget o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiWidget(ApiPieChartWidget o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiWidget(ApiStackedAreaChartWidget o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiWidget(ApiStackedBarchartWidget o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiWidget(ApiTableWidget o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiWidget(ApiTestTableWidget o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public ApiWidget(ApiTimeseriesWidget o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("ApiAgentStatusWidget", ApiAgentStatusWidget.class);
        schemas.put("ApiAlertListWidget", ApiAlertListWidget.class);
        schemas.put("ApiBoxAndWhiskersWidget", ApiBoxAndWhiskersWidget.class);
        schemas.put("ApiColorGridWidget", ApiColorGridWidget.class);
        schemas.put("ApiGeoMapWidget", ApiGeoMapWidget.class);
        schemas.put("ApiGroupedBarchartWidget", ApiGroupedBarchartWidget.class);
        schemas.put("ApiMultiMetricTableWidget", ApiMultiMetricTableWidget.class);
        schemas.put("ApiNumbersCardWidget", ApiNumbersCardWidget.class);
        schemas.put("ApiPieChartWidget", ApiPieChartWidget.class);
        schemas.put("ApiStackedAreaChartWidget", ApiStackedAreaChartWidget.class);
        schemas.put("ApiStackedBarchartWidget", ApiStackedBarchartWidget.class);
        schemas.put("ApiTableWidget", ApiTableWidget.class);
        schemas.put("ApiTestTableWidget", ApiTestTableWidget.class);
        schemas.put("ApiTimeseriesWidget", ApiTimeseriesWidget.class);
        JSON.registerDescendants(ApiWidget.class, Collections.unmodifiableMap(schemas));
        // Initialize and register the discriminator mappings.
        Map<String, Class<?>> mappings = new HashMap<String, Class<?>>();
        mappings.put("Agent Status", ApiAgentStatusWidget.class);
        mappings.put("Alert List", ApiAlertListWidget.class);
        mappings.put("Bar Chart: Grouped", ApiGroupedBarchartWidget.class);
        mappings.put("Bar Chart: Stacked", ApiStackedBarchartWidget.class);
        mappings.put("Box and Whiskers", ApiBoxAndWhiskersWidget.class);
        mappings.put("Color Grid", ApiColorGridWidget.class);
        mappings.put("Map", ApiGeoMapWidget.class);
        mappings.put("Multi Metric Table", ApiMultiMetricTableWidget.class);
        mappings.put("Number", ApiNumbersCardWidget.class);
        mappings.put("Pie Chart", ApiPieChartWidget.class);
        mappings.put("Table", ApiTableWidget.class);
        mappings.put("Test Table", ApiTestTableWidget.class);
        mappings.put("Time Series: Line", ApiTimeseriesWidget.class);
        mappings.put("Time Series: Stacked Area", ApiStackedAreaChartWidget.class);
        mappings.put("ApiWidget", ApiWidget.class);
        JSON.registerDiscriminator(ApiWidget.class, "type", mappings);
    }

    @Override
    public Map<String, Class<?>> getSchemas() {
        return ApiWidget.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * ApiAgentStatusWidget, ApiAlertListWidget, ApiBoxAndWhiskersWidget, ApiColorGridWidget, ApiGeoMapWidget, ApiGroupedBarchartWidget, ApiMultiMetricTableWidget, ApiNumbersCardWidget, ApiPieChartWidget, ApiStackedAreaChartWidget, ApiStackedBarchartWidget, ApiTableWidget, ApiTestTableWidget, ApiTimeseriesWidget
     *
     * It could be an instance of the 'oneOf' schemas.
     * The oneOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (JSON.isInstanceOf(ApiAgentStatusWidget.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ApiAlertListWidget.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ApiBoxAndWhiskersWidget.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ApiColorGridWidget.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ApiGeoMapWidget.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ApiGroupedBarchartWidget.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ApiMultiMetricTableWidget.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ApiNumbersCardWidget.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ApiPieChartWidget.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ApiStackedAreaChartWidget.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ApiStackedBarchartWidget.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ApiTableWidget.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ApiTestTableWidget.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ApiTimeseriesWidget.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be ApiAgentStatusWidget, ApiAlertListWidget, ApiBoxAndWhiskersWidget, ApiColorGridWidget, ApiGeoMapWidget, ApiGroupedBarchartWidget, ApiMultiMetricTableWidget, ApiNumbersCardWidget, ApiPieChartWidget, ApiStackedAreaChartWidget, ApiStackedBarchartWidget, ApiTableWidget, ApiTestTableWidget, ApiTimeseriesWidget");
    }

    /**
     * Get the actual instance, which can be the following:
     * ApiAgentStatusWidget, ApiAlertListWidget, ApiBoxAndWhiskersWidget, ApiColorGridWidget, ApiGeoMapWidget, ApiGroupedBarchartWidget, ApiMultiMetricTableWidget, ApiNumbersCardWidget, ApiPieChartWidget, ApiStackedAreaChartWidget, ApiStackedBarchartWidget, ApiTableWidget, ApiTestTableWidget, ApiTimeseriesWidget
     *
     * @return The actual instance (ApiAgentStatusWidget, ApiAlertListWidget, ApiBoxAndWhiskersWidget, ApiColorGridWidget, ApiGeoMapWidget, ApiGroupedBarchartWidget, ApiMultiMetricTableWidget, ApiNumbersCardWidget, ApiPieChartWidget, ApiStackedAreaChartWidget, ApiStackedBarchartWidget, ApiTableWidget, ApiTestTableWidget, ApiTimeseriesWidget)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `ApiAgentStatusWidget`. If the actual instance is not `ApiAgentStatusWidget`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ApiAgentStatusWidget`
     * @throws ClassCastException if the instance is not `ApiAgentStatusWidget`
     */
    public ApiAgentStatusWidget getApiAgentStatusWidget() throws ClassCastException {
        return (ApiAgentStatusWidget)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ApiAlertListWidget`. If the actual instance is not `ApiAlertListWidget`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ApiAlertListWidget`
     * @throws ClassCastException if the instance is not `ApiAlertListWidget`
     */
    public ApiAlertListWidget getApiAlertListWidget() throws ClassCastException {
        return (ApiAlertListWidget)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ApiBoxAndWhiskersWidget`. If the actual instance is not `ApiBoxAndWhiskersWidget`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ApiBoxAndWhiskersWidget`
     * @throws ClassCastException if the instance is not `ApiBoxAndWhiskersWidget`
     */
    public ApiBoxAndWhiskersWidget getApiBoxAndWhiskersWidget() throws ClassCastException {
        return (ApiBoxAndWhiskersWidget)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ApiColorGridWidget`. If the actual instance is not `ApiColorGridWidget`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ApiColorGridWidget`
     * @throws ClassCastException if the instance is not `ApiColorGridWidget`
     */
    public ApiColorGridWidget getApiColorGridWidget() throws ClassCastException {
        return (ApiColorGridWidget)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ApiGeoMapWidget`. If the actual instance is not `ApiGeoMapWidget`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ApiGeoMapWidget`
     * @throws ClassCastException if the instance is not `ApiGeoMapWidget`
     */
    public ApiGeoMapWidget getApiGeoMapWidget() throws ClassCastException {
        return (ApiGeoMapWidget)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ApiGroupedBarchartWidget`. If the actual instance is not `ApiGroupedBarchartWidget`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ApiGroupedBarchartWidget`
     * @throws ClassCastException if the instance is not `ApiGroupedBarchartWidget`
     */
    public ApiGroupedBarchartWidget getApiGroupedBarchartWidget() throws ClassCastException {
        return (ApiGroupedBarchartWidget)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ApiMultiMetricTableWidget`. If the actual instance is not `ApiMultiMetricTableWidget`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ApiMultiMetricTableWidget`
     * @throws ClassCastException if the instance is not `ApiMultiMetricTableWidget`
     */
    public ApiMultiMetricTableWidget getApiMultiMetricTableWidget() throws ClassCastException {
        return (ApiMultiMetricTableWidget)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ApiNumbersCardWidget`. If the actual instance is not `ApiNumbersCardWidget`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ApiNumbersCardWidget`
     * @throws ClassCastException if the instance is not `ApiNumbersCardWidget`
     */
    public ApiNumbersCardWidget getApiNumbersCardWidget() throws ClassCastException {
        return (ApiNumbersCardWidget)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ApiPieChartWidget`. If the actual instance is not `ApiPieChartWidget`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ApiPieChartWidget`
     * @throws ClassCastException if the instance is not `ApiPieChartWidget`
     */
    public ApiPieChartWidget getApiPieChartWidget() throws ClassCastException {
        return (ApiPieChartWidget)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ApiStackedAreaChartWidget`. If the actual instance is not `ApiStackedAreaChartWidget`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ApiStackedAreaChartWidget`
     * @throws ClassCastException if the instance is not `ApiStackedAreaChartWidget`
     */
    public ApiStackedAreaChartWidget getApiStackedAreaChartWidget() throws ClassCastException {
        return (ApiStackedAreaChartWidget)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ApiStackedBarchartWidget`. If the actual instance is not `ApiStackedBarchartWidget`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ApiStackedBarchartWidget`
     * @throws ClassCastException if the instance is not `ApiStackedBarchartWidget`
     */
    public ApiStackedBarchartWidget getApiStackedBarchartWidget() throws ClassCastException {
        return (ApiStackedBarchartWidget)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ApiTableWidget`. If the actual instance is not `ApiTableWidget`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ApiTableWidget`
     * @throws ClassCastException if the instance is not `ApiTableWidget`
     */
    public ApiTableWidget getApiTableWidget() throws ClassCastException {
        return (ApiTableWidget)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ApiTestTableWidget`. If the actual instance is not `ApiTestTableWidget`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ApiTestTableWidget`
     * @throws ClassCastException if the instance is not `ApiTestTableWidget`
     */
    public ApiTestTableWidget getApiTestTableWidget() throws ClassCastException {
        return (ApiTestTableWidget)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ApiTimeseriesWidget`. If the actual instance is not `ApiTimeseriesWidget`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ApiTimeseriesWidget`
     * @throws ClassCastException if the instance is not `ApiTimeseriesWidget`
     */
    public ApiTimeseriesWidget getApiTimeseriesWidget() throws ClassCastException {
        return (ApiTimeseriesWidget)super.getActualInstance();
    }



}


/*
 * Tests API
 *  ### Overview This API supports listing, creating, editing, and deleting Cloud and Enterprise Agent (CEA) based tests.
 *
 * The version of the OpenAPI document: 7.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.thousandeyes.api.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.thousandeyes.api.model.Agent;
import com.thousandeyes.api.model.AlertRule;
import com.thousandeyes.api.model.Monitor;
import com.thousandeyes.api.model.TestAuthType;
import com.thousandeyes.api.model.TestCustomHeaders;
import com.thousandeyes.api.model.TestInterval;
import com.thousandeyes.api.model.TestLabelsInner;
import com.thousandeyes.api.model.TestPageLoadingStrategy;
import com.thousandeyes.api.model.TestPathTraceMode;
import com.thousandeyes.api.model.TestProbeMode;
import com.thousandeyes.api.model.TestProtocol;
import com.thousandeyes.api.model.TestSharedAccountsInner;
import com.thousandeyes.api.model.TestSslVersionId;
import com.thousandeyes.api.model.TestSubInterval;
import com.thousandeyes.api.model.UnexpandedInstantTestLinks;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.thousandeyes.JSON;

/**
 * WebTransactionTest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-11-29T10:17:29.962605Z[Europe/London]")
public class WebTransactionTest {
  public static final String SERIALIZED_NAME_INTERVAL = "interval";
  @SerializedName(SERIALIZED_NAME_INTERVAL)
  private TestInterval interval;

  public static final String SERIALIZED_NAME_ALERTS_ENABLED = "alertsEnabled";
  @SerializedName(SERIALIZED_NAME_ALERTS_ENABLED)
  private Boolean alertsEnabled;

  public static final String SERIALIZED_NAME_ENABLED = "enabled";
  @SerializedName(SERIALIZED_NAME_ENABLED)
  private Boolean enabled = true;

  public static final String SERIALIZED_NAME_ALERT_RULES = "alertRules";
  @SerializedName(SERIALIZED_NAME_ALERT_RULES)
  private List<AlertRule> alertRules;

  public static final String SERIALIZED_NAME_CREATED_BY = "createdBy";
  @SerializedName(SERIALIZED_NAME_CREATED_BY)
  private String createdBy;

  public static final String SERIALIZED_NAME_CREATED_DATE = "createdDate";
  @SerializedName(SERIALIZED_NAME_CREATED_DATE)
  private OffsetDateTime createdDate;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_LIVE_SHARE = "liveShare";
  @SerializedName(SERIALIZED_NAME_LIVE_SHARE)
  private Boolean liveShare;

  public static final String SERIALIZED_NAME_MODIFIED_BY = "modifiedBy";
  @SerializedName(SERIALIZED_NAME_MODIFIED_BY)
  private String modifiedBy;

  public static final String SERIALIZED_NAME_MODIFIED_DATE = "modifiedDate";
  @SerializedName(SERIALIZED_NAME_MODIFIED_DATE)
  private OffsetDateTime modifiedDate;

  public static final String SERIALIZED_NAME_SAVED_EVENT = "savedEvent";
  @SerializedName(SERIALIZED_NAME_SAVED_EVENT)
  private Boolean savedEvent;

  public static final String SERIALIZED_NAME_TEST_ID = "testId";
  @SerializedName(SERIALIZED_NAME_TEST_ID)
  private String testId;

  public static final String SERIALIZED_NAME_TEST_NAME = "testName";
  @SerializedName(SERIALIZED_NAME_TEST_NAME)
  private String testName;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public static final String SERIALIZED_NAME_LINKS = "_links";
  @SerializedName(SERIALIZED_NAME_LINKS)
  private UnexpandedInstantTestLinks links;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private List<TestLabelsInner> labels;

  public static final String SERIALIZED_NAME_SHARED_WITH_ACCOUNTS = "sharedWithAccounts";
  @SerializedName(SERIALIZED_NAME_SHARED_WITH_ACCOUNTS)
  private List<TestSharedAccountsInner> sharedWithAccounts;

  public static final String SERIALIZED_NAME_AGENTS = "agents";
  @SerializedName(SERIALIZED_NAME_AGENTS)
  private List<Agent> agents = new ArrayList<>();

  public static final String SERIALIZED_NAME_AUTH_TYPE = "authType";
  @SerializedName(SERIALIZED_NAME_AUTH_TYPE)
  private TestAuthType authType = TestAuthType.NONE;

  public static final String SERIALIZED_NAME_BANDWIDTH_MEASUREMENTS = "bandwidthMeasurements";
  @SerializedName(SERIALIZED_NAME_BANDWIDTH_MEASUREMENTS)
  private Boolean bandwidthMeasurements;

  public static final String SERIALIZED_NAME_CLIENT_CERTIFICATE = "clientCertificate";
  @SerializedName(SERIALIZED_NAME_CLIENT_CERTIFICATE)
  private String clientCertificate;

  public static final String SERIALIZED_NAME_CONTENT_REGEX = "contentRegex";
  @SerializedName(SERIALIZED_NAME_CONTENT_REGEX)
  private String contentRegex;

  public static final String SERIALIZED_NAME_CREDENTIALS = "credentials";
  @SerializedName(SERIALIZED_NAME_CREDENTIALS)
  private List<String> credentials;

  public static final String SERIALIZED_NAME_CUSTOM_HEADERS = "customHeaders";
  @SerializedName(SERIALIZED_NAME_CUSTOM_HEADERS)
  private TestCustomHeaders customHeaders;

  public static final String SERIALIZED_NAME_DESIRED_STATUS_CODE = "desiredStatusCode";
  @SerializedName(SERIALIZED_NAME_DESIRED_STATUS_CODE)
  private String desiredStatusCode = "200";

  public static final String SERIALIZED_NAME_FOLLOW_REDIRECTS = "followRedirects";
  @SerializedName(SERIALIZED_NAME_FOLLOW_REDIRECTS)
  private Boolean followRedirects = true;

  public static final String SERIALIZED_NAME_HTTP_TARGET_TIME = "httpTargetTime";
  @SerializedName(SERIALIZED_NAME_HTTP_TARGET_TIME)
  private Integer httpTargetTime;

  public static final String SERIALIZED_NAME_HTTP_TIME_LIMIT = "httpTimeLimit";
  @SerializedName(SERIALIZED_NAME_HTTP_TIME_LIMIT)
  private Integer httpTimeLimit = 5;

  public static final String SERIALIZED_NAME_HTTP_VERSION = "httpVersion";
  @SerializedName(SERIALIZED_NAME_HTTP_VERSION)
  private Integer httpVersion = 2;

  public static final String SERIALIZED_NAME_INCLUDE_HEADERS = "includeHeaders";
  @SerializedName(SERIALIZED_NAME_INCLUDE_HEADERS)
  private Boolean includeHeaders = true;

  public static final String SERIALIZED_NAME_MTU_MEASUREMENTS = "mtuMeasurements";
  @SerializedName(SERIALIZED_NAME_MTU_MEASUREMENTS)
  private Boolean mtuMeasurements;

  public static final String SERIALIZED_NAME_NETWORK_MEASUREMENTS = "networkMeasurements";
  @SerializedName(SERIALIZED_NAME_NETWORK_MEASUREMENTS)
  private Boolean networkMeasurements = true;

  public static final String SERIALIZED_NAME_NUM_PATH_TRACES = "numPathTraces";
  @SerializedName(SERIALIZED_NAME_NUM_PATH_TRACES)
  private Integer numPathTraces = 3;

  public static final String SERIALIZED_NAME_PASSWORD = "password";
  @SerializedName(SERIALIZED_NAME_PASSWORD)
  private String password;

  public static final String SERIALIZED_NAME_PATH_TRACE_MODE = "pathTraceMode";
  @SerializedName(SERIALIZED_NAME_PATH_TRACE_MODE)
  private TestPathTraceMode pathTraceMode = TestPathTraceMode.CLASSIC;

  public static final String SERIALIZED_NAME_PROBE_MODE = "probeMode";
  @SerializedName(SERIALIZED_NAME_PROBE_MODE)
  private TestProbeMode probeMode = TestProbeMode.AUTO;

  public static final String SERIALIZED_NAME_PROTOCOL = "protocol";
  @SerializedName(SERIALIZED_NAME_PROTOCOL)
  private TestProtocol protocol = TestProtocol.TCP;

  public static final String SERIALIZED_NAME_SSL_VERSION = "sslVersion";
  @SerializedName(SERIALIZED_NAME_SSL_VERSION)
  private String sslVersion;

  public static final String SERIALIZED_NAME_SSL_VERSION_ID = "sslVersionId";
  @SerializedName(SERIALIZED_NAME_SSL_VERSION_ID)
  private TestSslVersionId sslVersionId;

  public static final String SERIALIZED_NAME_TARGET_TIME = "targetTime";
  @SerializedName(SERIALIZED_NAME_TARGET_TIME)
  private Integer targetTime;

  public static final String SERIALIZED_NAME_TIME_LIMIT = "timeLimit";
  @SerializedName(SERIALIZED_NAME_TIME_LIMIT)
  private Integer timeLimit = 30;

  public static final String SERIALIZED_NAME_TRANSACTION_SCRIPT = "transactionScript";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_SCRIPT)
  private String transactionScript;

  public static final String SERIALIZED_NAME_URL = "url";
  @SerializedName(SERIALIZED_NAME_URL)
  private String url;

  public static final String SERIALIZED_NAME_USE_NTLM = "useNtlm";
  @SerializedName(SERIALIZED_NAME_USE_NTLM)
  private Boolean useNtlm;

  public static final String SERIALIZED_NAME_USER_AGENT = "userAgent";
  @SerializedName(SERIALIZED_NAME_USER_AGENT)
  private String userAgent;

  public static final String SERIALIZED_NAME_USERNAME = "username";
  @SerializedName(SERIALIZED_NAME_USERNAME)
  private String username;

  public static final String SERIALIZED_NAME_VERIFY_CERTIFICATE = "verifyCertificate";
  @SerializedName(SERIALIZED_NAME_VERIFY_CERTIFICATE)
  private Boolean verifyCertificate = false;

  public static final String SERIALIZED_NAME_BLOCK_DOMAINS = "blockDomains";
  @SerializedName(SERIALIZED_NAME_BLOCK_DOMAINS)
  private String blockDomains;

  public static final String SERIALIZED_NAME_DISABLE_SCREENSHOT = "disableScreenshot";
  @SerializedName(SERIALIZED_NAME_DISABLE_SCREENSHOT)
  private Boolean disableScreenshot = false;

  public static final String SERIALIZED_NAME_ALLOW_MIC_AND_CAMERA = "allowMicAndCamera";
  @SerializedName(SERIALIZED_NAME_ALLOW_MIC_AND_CAMERA)
  private Boolean allowMicAndCamera = false;

  public static final String SERIALIZED_NAME_ALLOW_GEOLOCATION = "allowGeolocation";
  @SerializedName(SERIALIZED_NAME_ALLOW_GEOLOCATION)
  private Boolean allowGeolocation = false;

  public static final String SERIALIZED_NAME_BROWSER_LANGUAGE = "browserLanguage";
  @SerializedName(SERIALIZED_NAME_BROWSER_LANGUAGE)
  private String browserLanguage;

  public static final String SERIALIZED_NAME_PAGE_LOADING_STRATEGY = "pageLoadingStrategy";
  @SerializedName(SERIALIZED_NAME_PAGE_LOADING_STRATEGY)
  private TestPageLoadingStrategy pageLoadingStrategy = TestPageLoadingStrategy.NORMAL;

  public static final String SERIALIZED_NAME_FIXED_PACKET_RATE = "fixedPacketRate";
  @SerializedName(SERIALIZED_NAME_FIXED_PACKET_RATE)
  private Integer fixedPacketRate;

  public static final String SERIALIZED_NAME_BGP_MEASUREMENTS = "bgpMeasurements";
  @SerializedName(SERIALIZED_NAME_BGP_MEASUREMENTS)
  private Boolean bgpMeasurements = true;

  public static final String SERIALIZED_NAME_MONITORS = "monitors";
  @SerializedName(SERIALIZED_NAME_MONITORS)
  private List<Monitor> monitors;

  public static final String SERIALIZED_NAME_SUBINTERVAL = "subinterval";
  @SerializedName(SERIALIZED_NAME_SUBINTERVAL)
  private TestSubInterval subinterval;

  public WebTransactionTest() {
  }

  
  public WebTransactionTest(
     String createdBy, 
     OffsetDateTime createdDate, 
     Boolean liveShare, 
     String modifiedBy, 
     OffsetDateTime modifiedDate, 
     Boolean savedEvent, 
     String testId, 
     String type, 
     List<TestLabelsInner> labels, 
     List<TestSharedAccountsInner> sharedWithAccounts, 
     List<Agent> agents, 
     String sslVersion, 
     List<Monitor> monitors
  ) {
    this();
    this.createdBy = createdBy;
    this.createdDate = createdDate;
    this.liveShare = liveShare;
    this.modifiedBy = modifiedBy;
    this.modifiedDate = modifiedDate;
    this.savedEvent = savedEvent;
    this.testId = testId;
    this.type = type;
    this.labels = labels;
    this.sharedWithAccounts = sharedWithAccounts;
    this.agents = agents;
    this.sslVersion = sslVersion;
    this.monitors = monitors;
  }

  public WebTransactionTest interval(TestInterval interval) {
    
    this.interval = interval;
    return this;
  }

   /**
   * Get interval
   * @return interval
  **/
  @javax.annotation.Nonnull
  public TestInterval getInterval() {
    return interval;
  }


  public void setInterval(TestInterval interval) {
    this.interval = interval;
  }


  public WebTransactionTest alertsEnabled(Boolean alertsEnabled) {
    
    this.alertsEnabled = alertsEnabled;
    return this;
  }

   /**
   * Indicates if alerts are enabled.
   * @return alertsEnabled
  **/
  @javax.annotation.Nullable
  public Boolean getAlertsEnabled() {
    return alertsEnabled;
  }


  public void setAlertsEnabled(Boolean alertsEnabled) {
    this.alertsEnabled = alertsEnabled;
  }


  public WebTransactionTest enabled(Boolean enabled) {
    
    this.enabled = enabled;
    return this;
  }

   /**
   * Test is enabled.
   * @return enabled
  **/
  @javax.annotation.Nullable
  public Boolean getEnabled() {
    return enabled;
  }


  public void setEnabled(Boolean enabled) {
    this.enabled = enabled;
  }


  public WebTransactionTest alertRules(List<AlertRule> alertRules) {
    
    this.alertRules = alertRules;
    return this;
  }

  public WebTransactionTest addAlertRulesItem(AlertRule alertRulesItem) {
    if (this.alertRules == null) {
      this.alertRules = new ArrayList<>();
    }
    this.alertRules.add(alertRulesItem);
    return this;
  }

   /**
   * Contains list of enabled alert rule objects.
   * @return alertRules
  **/
  @javax.annotation.Nullable
  public List<AlertRule> getAlertRules() {
    return alertRules;
  }


  public void setAlertRules(List<AlertRule> alertRules) {
    this.alertRules = alertRules;
  }


   /**
   * User that created the test.
   * @return createdBy
  **/
  @javax.annotation.Nullable
  public String getCreatedBy() {
    return createdBy;
  }




   /**
   * UTC created date (ISO date-time format).
   * @return createdDate
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedDate() {
    return createdDate;
  }




  public WebTransactionTest description(String description) {
    
    this.description = description;
    return this;
  }

   /**
   * A description of the test.
   * @return description
  **/
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }


  public void setDescription(String description) {
    this.description = description;
  }


   /**
   * Indicates if the test is shared with the account group.
   * @return liveShare
  **/
  @javax.annotation.Nullable
  public Boolean getLiveShare() {
    return liveShare;
  }




   /**
   * User that modified the test.
   * @return modifiedBy
  **/
  @javax.annotation.Nullable
  public String getModifiedBy() {
    return modifiedBy;
  }




   /**
   * UTC last modification date (ISO date-time format).
   * @return modifiedDate
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getModifiedDate() {
    return modifiedDate;
  }




   /**
   * Indicates if the test is a saved event.
   * @return savedEvent
  **/
  @javax.annotation.Nullable
  public Boolean getSavedEvent() {
    return savedEvent;
  }




   /**
   * Each test is assigned an unique ID; this is used to access test information and results from other endpoints.
   * @return testId
  **/
  @javax.annotation.Nullable
  public String getTestId() {
    return testId;
  }




  public WebTransactionTest testName(String testName) {
    
    this.testName = testName;
    return this;
  }

   /**
   * The name of the test. Test name must be unique.
   * @return testName
  **/
  @javax.annotation.Nullable
  public String getTestName() {
    return testName;
  }


  public void setTestName(String testName) {
    this.testName = testName;
  }


   /**
   * Get type
   * @return type
  **/
  @javax.annotation.Nullable
  public String getType() {
    return type;
  }




  public WebTransactionTest links(UnexpandedInstantTestLinks links) {
    
    this.links = links;
    return this;
  }

   /**
   * Get links
   * @return links
  **/
  @javax.annotation.Nullable
  public UnexpandedInstantTestLinks getLinks() {
    return links;
  }


  public void setLinks(UnexpandedInstantTestLinks links) {
    this.links = links;
  }


   /**
   * Get labels
   * @return labels
  **/
  @javax.annotation.Nullable
  public List<TestLabelsInner> getLabels() {
    return labels;
  }




   /**
   * Get sharedWithAccounts
   * @return sharedWithAccounts
  **/
  @javax.annotation.Nullable
  public List<TestSharedAccountsInner> getSharedWithAccounts() {
    return sharedWithAccounts;
  }




   /**
   * Contains list of agents.
   * @return agents
  **/
  @javax.annotation.Nonnull
  public List<Agent> getAgents() {
    return agents;
  }




  public WebTransactionTest authType(TestAuthType authType) {
    
    this.authType = authType;
    return this;
  }

   /**
   * Get authType
   * @return authType
  **/
  @javax.annotation.Nullable
  public TestAuthType getAuthType() {
    return authType;
  }


  public void setAuthType(TestAuthType authType) {
    this.authType = authType;
  }


  public WebTransactionTest bandwidthMeasurements(Boolean bandwidthMeasurements) {
    
    this.bandwidthMeasurements = bandwidthMeasurements;
    return this;
  }

   /**
   * Set to &#x60;true&#x60; to enable bandwidth measurements, only applies to Enterprise agents assigned to the test.
   * @return bandwidthMeasurements
  **/
  @javax.annotation.Nullable
  public Boolean getBandwidthMeasurements() {
    return bandwidthMeasurements;
  }


  public void setBandwidthMeasurements(Boolean bandwidthMeasurements) {
    this.bandwidthMeasurements = bandwidthMeasurements;
  }


  public WebTransactionTest clientCertificate(String clientCertificate) {
    
    this.clientCertificate = clientCertificate;
    return this;
  }

   /**
   * String representation (containing newline characters) of client certificate, the private key must be placed first, then the certificate.
   * @return clientCertificate
  **/
  @javax.annotation.Nullable
  public String getClientCertificate() {
    return clientCertificate;
  }


  public void setClientCertificate(String clientCertificate) {
    this.clientCertificate = clientCertificate;
  }


  public WebTransactionTest contentRegex(String contentRegex) {
    
    this.contentRegex = contentRegex;
    return this;
  }

   /**
   * Verify content using a regular expression. This field does not require escaping.
   * @return contentRegex
  **/
  @javax.annotation.Nullable
  public String getContentRegex() {
    return contentRegex;
  }


  public void setContentRegex(String contentRegex) {
    this.contentRegex = contentRegex;
  }


  public WebTransactionTest credentials(List<String> credentials) {
    
    this.credentials = credentials;
    return this;
  }

  public WebTransactionTest addCredentialsItem(String credentialsItem) {
    if (this.credentials == null) {
      this.credentials = new ArrayList<>();
    }
    this.credentials.add(credentialsItem);
    return this;
  }

   /**
   * Contains a list of credential IDs (get &#x60;credentialId&#x60; from &#x60;/credentials&#x60; endpoint).
   * @return credentials
  **/
  @javax.annotation.Nullable
  public List<String> getCredentials() {
    return credentials;
  }


  public void setCredentials(List<String> credentials) {
    this.credentials = credentials;
  }


  public WebTransactionTest customHeaders(TestCustomHeaders customHeaders) {
    
    this.customHeaders = customHeaders;
    return this;
  }

   /**
   * Get customHeaders
   * @return customHeaders
  **/
  @javax.annotation.Nullable
  public TestCustomHeaders getCustomHeaders() {
    return customHeaders;
  }


  public void setCustomHeaders(TestCustomHeaders customHeaders) {
    this.customHeaders = customHeaders;
  }


  public WebTransactionTest desiredStatusCode(String desiredStatusCode) {
    
    this.desiredStatusCode = desiredStatusCode;
    return this;
  }

   /**
   * Specify the HTTP status code value that indicates a successful response.
   * @return desiredStatusCode
  **/
  @javax.annotation.Nullable
  public String getDesiredStatusCode() {
    return desiredStatusCode;
  }


  public void setDesiredStatusCode(String desiredStatusCode) {
    this.desiredStatusCode = desiredStatusCode;
  }


  public WebTransactionTest followRedirects(Boolean followRedirects) {
    
    this.followRedirects = followRedirects;
    return this;
  }

   /**
   * To disable following HTTP/301 or HTTP/302 redirect directives, set this parameter to false.
   * @return followRedirects
  **/
  @javax.annotation.Nullable
  public Boolean getFollowRedirects() {
    return followRedirects;
  }


  public void setFollowRedirects(Boolean followRedirects) {
    this.followRedirects = followRedirects;
  }


  public WebTransactionTest httpTargetTime(Integer httpTargetTime) {
    
    this.httpTargetTime = httpTargetTime;
    return this;
  }

   /**
   * Target time for HTTP server completion, specified in milliseconds.
   * minimum: 100
   * maximum: 5000
   * @return httpTargetTime
  **/
  @javax.annotation.Nullable
  public Integer getHttpTargetTime() {
    return httpTargetTime;
  }


  public void setHttpTargetTime(Integer httpTargetTime) {
    this.httpTargetTime = httpTargetTime;
  }


  public WebTransactionTest httpTimeLimit(Integer httpTimeLimit) {
    
    this.httpTimeLimit = httpTimeLimit;
    return this;
  }

   /**
   * HTTP time limit in seconds.
   * minimum: 5
   * maximum: 60
   * @return httpTimeLimit
  **/
  @javax.annotation.Nullable
  public Integer getHttpTimeLimit() {
    return httpTimeLimit;
  }


  public void setHttpTimeLimit(Integer httpTimeLimit) {
    this.httpTimeLimit = httpTimeLimit;
  }


  public WebTransactionTest httpVersion(Integer httpVersion) {
    
    this.httpVersion = httpVersion;
    return this;
  }

   /**
   * HTTP protocol version. Set to &#39;2&#39; to prefer HTTP/2, or &#39;1&#39; to use only HTTP/1.1.
   * minimum: 1
   * maximum: 2
   * @return httpVersion
  **/
  @javax.annotation.Nullable
  public Integer getHttpVersion() {
    return httpVersion;
  }


  public void setHttpVersion(Integer httpVersion) {
    this.httpVersion = httpVersion;
  }


  public WebTransactionTest includeHeaders(Boolean includeHeaders) {
    
    this.includeHeaders = includeHeaders;
    return this;
  }

   /**
   * Set to &#x60;true&#x60; to capture response headers for objects loaded by the test.
   * @return includeHeaders
  **/
  @javax.annotation.Nullable
  public Boolean getIncludeHeaders() {
    return includeHeaders;
  }


  public void setIncludeHeaders(Boolean includeHeaders) {
    this.includeHeaders = includeHeaders;
  }


  public WebTransactionTest mtuMeasurements(Boolean mtuMeasurements) {
    
    this.mtuMeasurements = mtuMeasurements;
    return this;
  }

   /**
   * Set &#x60;true&#x60; to measure MTU sizes on network from agents to the target.
   * @return mtuMeasurements
  **/
  @javax.annotation.Nullable
  public Boolean getMtuMeasurements() {
    return mtuMeasurements;
  }


  public void setMtuMeasurements(Boolean mtuMeasurements) {
    this.mtuMeasurements = mtuMeasurements;
  }


  public WebTransactionTest networkMeasurements(Boolean networkMeasurements) {
    
    this.networkMeasurements = networkMeasurements;
    return this;
  }

   /**
   * Enable or disable network measurements. Set to true to enable or false to disable network measurements.
   * @return networkMeasurements
  **/
  @javax.annotation.Nullable
  public Boolean getNetworkMeasurements() {
    return networkMeasurements;
  }


  public void setNetworkMeasurements(Boolean networkMeasurements) {
    this.networkMeasurements = networkMeasurements;
  }


  public WebTransactionTest numPathTraces(Integer numPathTraces) {
    
    this.numPathTraces = numPathTraces;
    return this;
  }

   /**
   * Number of path traces executed by the agent.
   * minimum: 3
   * maximum: 10
   * @return numPathTraces
  **/
  @javax.annotation.Nullable
  public Integer getNumPathTraces() {
    return numPathTraces;
  }


  public void setNumPathTraces(Integer numPathTraces) {
    this.numPathTraces = numPathTraces;
  }


  public WebTransactionTest password(String password) {
    
    this.password = password;
    return this;
  }

   /**
   * Password for Basic/NTLM authentication.
   * @return password
  **/
  @javax.annotation.Nullable
  public String getPassword() {
    return password;
  }


  public void setPassword(String password) {
    this.password = password;
  }


  public WebTransactionTest pathTraceMode(TestPathTraceMode pathTraceMode) {
    
    this.pathTraceMode = pathTraceMode;
    return this;
  }

   /**
   * Get pathTraceMode
   * @return pathTraceMode
  **/
  @javax.annotation.Nullable
  public TestPathTraceMode getPathTraceMode() {
    return pathTraceMode;
  }


  public void setPathTraceMode(TestPathTraceMode pathTraceMode) {
    this.pathTraceMode = pathTraceMode;
  }


  public WebTransactionTest probeMode(TestProbeMode probeMode) {
    
    this.probeMode = probeMode;
    return this;
  }

   /**
   * Get probeMode
   * @return probeMode
  **/
  @javax.annotation.Nullable
  public TestProbeMode getProbeMode() {
    return probeMode;
  }


  public void setProbeMode(TestProbeMode probeMode) {
    this.probeMode = probeMode;
  }


  public WebTransactionTest protocol(TestProtocol protocol) {
    
    this.protocol = protocol;
    return this;
  }

   /**
   * Get protocol
   * @return protocol
  **/
  @javax.annotation.Nullable
  public TestProtocol getProtocol() {
    return protocol;
  }


  public void setProtocol(TestProtocol protocol) {
    this.protocol = protocol;
  }


   /**
   * Reflects the verbose SSL protocol version used by a test.
   * @return sslVersion
  **/
  @javax.annotation.Nullable
  public String getSslVersion() {
    return sslVersion;
  }




  public WebTransactionTest sslVersionId(TestSslVersionId sslVersionId) {
    
    this.sslVersionId = sslVersionId;
    return this;
  }

   /**
   * Get sslVersionId
   * @return sslVersionId
  **/
  @javax.annotation.Nullable
  public TestSslVersionId getSslVersionId() {
    return sslVersionId;
  }


  public void setSslVersionId(TestSslVersionId sslVersionId) {
    this.sslVersionId = sslVersionId;
  }


  public WebTransactionTest targetTime(Integer targetTime) {
    
    this.targetTime = targetTime;
    return this;
  }

   /**
   * Target time for completion, defaults to 50% of time limit specified in seconds.
   * minimum: 1
   * maximum: 60
   * @return targetTime
  **/
  @javax.annotation.Nullable
  public Integer getTargetTime() {
    return targetTime;
  }


  public void setTargetTime(Integer targetTime) {
    this.targetTime = targetTime;
  }


  public WebTransactionTest timeLimit(Integer timeLimit) {
    
    this.timeLimit = timeLimit;
    return this;
  }

   /**
   * Time limit for transaction in seconds.
   * minimum: 5
   * maximum: 180
   * @return timeLimit
  **/
  @javax.annotation.Nullable
  public Integer getTimeLimit() {
    return timeLimit;
  }


  public void setTimeLimit(Integer timeLimit) {
    this.timeLimit = timeLimit;
  }


  public WebTransactionTest transactionScript(String transactionScript) {
    
    this.transactionScript = transactionScript;
    return this;
  }

   /**
   * JavaScript of a web transaction test. Quotes must be escaped (precede \&quot; characters with \\ ).
   * @return transactionScript
  **/
  @javax.annotation.Nonnull
  public String getTransactionScript() {
    return transactionScript;
  }


  public void setTransactionScript(String transactionScript) {
    this.transactionScript = transactionScript;
  }


  public WebTransactionTest url(String url) {
    
    this.url = url;
    return this;
  }

   /**
   * Target for the test.
   * @return url
  **/
  @javax.annotation.Nonnull
  public String getUrl() {
    return url;
  }


  public void setUrl(String url) {
    this.url = url;
  }


  public WebTransactionTest useNtlm(Boolean useNtlm) {
    
    this.useNtlm = useNtlm;
    return this;
  }

   /**
   * Set to true to use NTLM, false to use Basic Authentication. Requires username and password to be set.
   * @return useNtlm
  **/
  @javax.annotation.Nullable
  public Boolean getUseNtlm() {
    return useNtlm;
  }


  public void setUseNtlm(Boolean useNtlm) {
    this.useNtlm = useNtlm;
  }


  public WebTransactionTest userAgent(String userAgent) {
    
    this.userAgent = userAgent;
    return this;
  }

   /**
   * User-agent string to be provided during the test.
   * @return userAgent
  **/
  @javax.annotation.Nullable
  public String getUserAgent() {
    return userAgent;
  }


  public void setUserAgent(String userAgent) {
    this.userAgent = userAgent;
  }


  public WebTransactionTest username(String username) {
    
    this.username = username;
    return this;
  }

   /**
   * Username for Basic/NTLM authentication.
   * @return username
  **/
  @javax.annotation.Nullable
  public String getUsername() {
    return username;
  }


  public void setUsername(String username) {
    this.username = username;
  }


  public WebTransactionTest verifyCertificate(Boolean verifyCertificate) {
    
    this.verifyCertificate = verifyCertificate;
    return this;
  }

   /**
   * Ignore or acknowledge certificate errors. Set to false to ignore certificate errors.
   * @return verifyCertificate
  **/
  @javax.annotation.Nullable
  public Boolean getVerifyCertificate() {
    return verifyCertificate;
  }


  public void setVerifyCertificate(Boolean verifyCertificate) {
    this.verifyCertificate = verifyCertificate;
  }


  public WebTransactionTest blockDomains(String blockDomains) {
    
    this.blockDomains = blockDomains;
    return this;
  }

   /**
   * Domains or full object URLs to be excluded from metrics and waterfall data for transaction tests.
   * @return blockDomains
  **/
  @javax.annotation.Nullable
  public String getBlockDomains() {
    return blockDomains;
  }


  public void setBlockDomains(String blockDomains) {
    this.blockDomains = blockDomains;
  }


  public WebTransactionTest disableScreenshot(Boolean disableScreenshot) {
    
    this.disableScreenshot = disableScreenshot;
    return this;
  }

   /**
   * Enables or disables screenshots on error. Set true to not capture
   * @return disableScreenshot
  **/
  @javax.annotation.Nullable
  public Boolean getDisableScreenshot() {
    return disableScreenshot;
  }


  public void setDisableScreenshot(Boolean disableScreenshot) {
    this.disableScreenshot = disableScreenshot;
  }


  public WebTransactionTest allowMicAndCamera(Boolean allowMicAndCamera) {
    
    this.allowMicAndCamera = allowMicAndCamera;
    return this;
  }

   /**
   * Set true allow the use of a fake mic and camera in the browser.
   * @return allowMicAndCamera
  **/
  @javax.annotation.Nullable
  public Boolean getAllowMicAndCamera() {
    return allowMicAndCamera;
  }


  public void setAllowMicAndCamera(Boolean allowMicAndCamera) {
    this.allowMicAndCamera = allowMicAndCamera;
  }


  public WebTransactionTest allowGeolocation(Boolean allowGeolocation) {
    
    this.allowGeolocation = allowGeolocation;
    return this;
  }

   /**
   * Set true to use the agentâ€™s geolocation by the web page.
   * @return allowGeolocation
  **/
  @javax.annotation.Nullable
  public Boolean getAllowGeolocation() {
    return allowGeolocation;
  }


  public void setAllowGeolocation(Boolean allowGeolocation) {
    this.allowGeolocation = allowGeolocation;
  }


  public WebTransactionTest browserLanguage(String browserLanguage) {
    
    this.browserLanguage = browserLanguage;
    return this;
  }

   /**
   * Set one of the available browser language that you want to use to configure the browser.
   * @return browserLanguage
  **/
  @javax.annotation.Nullable
  public String getBrowserLanguage() {
    return browserLanguage;
  }


  public void setBrowserLanguage(String browserLanguage) {
    this.browserLanguage = browserLanguage;
  }


  public WebTransactionTest pageLoadingStrategy(TestPageLoadingStrategy pageLoadingStrategy) {
    
    this.pageLoadingStrategy = pageLoadingStrategy;
    return this;
  }

   /**
   * Get pageLoadingStrategy
   * @return pageLoadingStrategy
  **/
  @javax.annotation.Nullable
  public TestPageLoadingStrategy getPageLoadingStrategy() {
    return pageLoadingStrategy;
  }


  public void setPageLoadingStrategy(TestPageLoadingStrategy pageLoadingStrategy) {
    this.pageLoadingStrategy = pageLoadingStrategy;
  }


  public WebTransactionTest fixedPacketRate(Integer fixedPacketRate) {
    
    this.fixedPacketRate = fixedPacketRate;
    return this;
  }

   /**
   * Sets packets rate sent to measure the network in packets per second.
   * minimum: 0
   * maximum: 100
   * @return fixedPacketRate
  **/
  @javax.annotation.Nullable
  public Integer getFixedPacketRate() {
    return fixedPacketRate;
  }


  public void setFixedPacketRate(Integer fixedPacketRate) {
    this.fixedPacketRate = fixedPacketRate;
  }


  public WebTransactionTest bgpMeasurements(Boolean bgpMeasurements) {
    
    this.bgpMeasurements = bgpMeasurements;
    return this;
  }

   /**
   * Set to &#x60;true&#x60; to enable bgp measurements.
   * @return bgpMeasurements
  **/
  @javax.annotation.Nullable
  public Boolean getBgpMeasurements() {
    return bgpMeasurements;
  }


  public void setBgpMeasurements(Boolean bgpMeasurements) {
    this.bgpMeasurements = bgpMeasurements;
  }


   /**
   * Contains list of enabled BGP monitors.
   * @return monitors
  **/
  @javax.annotation.Nullable
  public List<Monitor> getMonitors() {
    return monitors;
  }




  public WebTransactionTest subinterval(TestSubInterval subinterval) {
    
    this.subinterval = subinterval;
    return this;
  }

   /**
   * Get subinterval
   * @return subinterval
  **/
  @javax.annotation.Nullable
  public TestSubInterval getSubinterval() {
    return subinterval;
  }


  public void setSubinterval(TestSubInterval subinterval) {
    this.subinterval = subinterval;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    WebTransactionTest webTransactionTest = (WebTransactionTest) o;
    return Objects.equals(this.interval, webTransactionTest.interval) &&
        Objects.equals(this.alertsEnabled, webTransactionTest.alertsEnabled) &&
        Objects.equals(this.enabled, webTransactionTest.enabled) &&
        Objects.equals(this.alertRules, webTransactionTest.alertRules) &&
        Objects.equals(this.createdBy, webTransactionTest.createdBy) &&
        Objects.equals(this.createdDate, webTransactionTest.createdDate) &&
        Objects.equals(this.description, webTransactionTest.description) &&
        Objects.equals(this.liveShare, webTransactionTest.liveShare) &&
        Objects.equals(this.modifiedBy, webTransactionTest.modifiedBy) &&
        Objects.equals(this.modifiedDate, webTransactionTest.modifiedDate) &&
        Objects.equals(this.savedEvent, webTransactionTest.savedEvent) &&
        Objects.equals(this.testId, webTransactionTest.testId) &&
        Objects.equals(this.testName, webTransactionTest.testName) &&
        Objects.equals(this.type, webTransactionTest.type) &&
        Objects.equals(this.links, webTransactionTest.links) &&
        Objects.equals(this.labels, webTransactionTest.labels) &&
        Objects.equals(this.sharedWithAccounts, webTransactionTest.sharedWithAccounts) &&
        Objects.equals(this.agents, webTransactionTest.agents) &&
        Objects.equals(this.authType, webTransactionTest.authType) &&
        Objects.equals(this.bandwidthMeasurements, webTransactionTest.bandwidthMeasurements) &&
        Objects.equals(this.clientCertificate, webTransactionTest.clientCertificate) &&
        Objects.equals(this.contentRegex, webTransactionTest.contentRegex) &&
        Objects.equals(this.credentials, webTransactionTest.credentials) &&
        Objects.equals(this.customHeaders, webTransactionTest.customHeaders) &&
        Objects.equals(this.desiredStatusCode, webTransactionTest.desiredStatusCode) &&
        Objects.equals(this.followRedirects, webTransactionTest.followRedirects) &&
        Objects.equals(this.httpTargetTime, webTransactionTest.httpTargetTime) &&
        Objects.equals(this.httpTimeLimit, webTransactionTest.httpTimeLimit) &&
        Objects.equals(this.httpVersion, webTransactionTest.httpVersion) &&
        Objects.equals(this.includeHeaders, webTransactionTest.includeHeaders) &&
        Objects.equals(this.mtuMeasurements, webTransactionTest.mtuMeasurements) &&
        Objects.equals(this.networkMeasurements, webTransactionTest.networkMeasurements) &&
        Objects.equals(this.numPathTraces, webTransactionTest.numPathTraces) &&
        Objects.equals(this.password, webTransactionTest.password) &&
        Objects.equals(this.pathTraceMode, webTransactionTest.pathTraceMode) &&
        Objects.equals(this.probeMode, webTransactionTest.probeMode) &&
        Objects.equals(this.protocol, webTransactionTest.protocol) &&
        Objects.equals(this.sslVersion, webTransactionTest.sslVersion) &&
        Objects.equals(this.sslVersionId, webTransactionTest.sslVersionId) &&
        Objects.equals(this.targetTime, webTransactionTest.targetTime) &&
        Objects.equals(this.timeLimit, webTransactionTest.timeLimit) &&
        Objects.equals(this.transactionScript, webTransactionTest.transactionScript) &&
        Objects.equals(this.url, webTransactionTest.url) &&
        Objects.equals(this.useNtlm, webTransactionTest.useNtlm) &&
        Objects.equals(this.userAgent, webTransactionTest.userAgent) &&
        Objects.equals(this.username, webTransactionTest.username) &&
        Objects.equals(this.verifyCertificate, webTransactionTest.verifyCertificate) &&
        Objects.equals(this.blockDomains, webTransactionTest.blockDomains) &&
        Objects.equals(this.disableScreenshot, webTransactionTest.disableScreenshot) &&
        Objects.equals(this.allowMicAndCamera, webTransactionTest.allowMicAndCamera) &&
        Objects.equals(this.allowGeolocation, webTransactionTest.allowGeolocation) &&
        Objects.equals(this.browserLanguage, webTransactionTest.browserLanguage) &&
        Objects.equals(this.pageLoadingStrategy, webTransactionTest.pageLoadingStrategy) &&
        Objects.equals(this.fixedPacketRate, webTransactionTest.fixedPacketRate) &&
        Objects.equals(this.bgpMeasurements, webTransactionTest.bgpMeasurements) &&
        Objects.equals(this.monitors, webTransactionTest.monitors) &&
        Objects.equals(this.subinterval, webTransactionTest.subinterval);
  }

  @Override
  public int hashCode() {
    return Objects.hash(interval, alertsEnabled, enabled, alertRules, createdBy, createdDate, description, liveShare, modifiedBy, modifiedDate, savedEvent, testId, testName, type, links, labels, sharedWithAccounts, agents, authType, bandwidthMeasurements, clientCertificate, contentRegex, credentials, customHeaders, desiredStatusCode, followRedirects, httpTargetTime, httpTimeLimit, httpVersion, includeHeaders, mtuMeasurements, networkMeasurements, numPathTraces, password, pathTraceMode, probeMode, protocol, sslVersion, sslVersionId, targetTime, timeLimit, transactionScript, url, useNtlm, userAgent, username, verifyCertificate, blockDomains, disableScreenshot, allowMicAndCamera, allowGeolocation, browserLanguage, pageLoadingStrategy, fixedPacketRate, bgpMeasurements, monitors, subinterval);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class WebTransactionTest {\n");
    sb.append("    interval: ").append(toIndentedString(interval)).append("\n");
    sb.append("    alertsEnabled: ").append(toIndentedString(alertsEnabled)).append("\n");
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    alertRules: ").append(toIndentedString(alertRules)).append("\n");
    sb.append("    createdBy: ").append(toIndentedString(createdBy)).append("\n");
    sb.append("    createdDate: ").append(toIndentedString(createdDate)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    liveShare: ").append(toIndentedString(liveShare)).append("\n");
    sb.append("    modifiedBy: ").append(toIndentedString(modifiedBy)).append("\n");
    sb.append("    modifiedDate: ").append(toIndentedString(modifiedDate)).append("\n");
    sb.append("    savedEvent: ").append(toIndentedString(savedEvent)).append("\n");
    sb.append("    testId: ").append(toIndentedString(testId)).append("\n");
    sb.append("    testName: ").append(toIndentedString(testName)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    links: ").append(toIndentedString(links)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    sharedWithAccounts: ").append(toIndentedString(sharedWithAccounts)).append("\n");
    sb.append("    agents: ").append(toIndentedString(agents)).append("\n");
    sb.append("    authType: ").append(toIndentedString(authType)).append("\n");
    sb.append("    bandwidthMeasurements: ").append(toIndentedString(bandwidthMeasurements)).append("\n");
    sb.append("    clientCertificate: ").append(toIndentedString(clientCertificate)).append("\n");
    sb.append("    contentRegex: ").append(toIndentedString(contentRegex)).append("\n");
    sb.append("    credentials: ").append(toIndentedString(credentials)).append("\n");
    sb.append("    customHeaders: ").append(toIndentedString(customHeaders)).append("\n");
    sb.append("    desiredStatusCode: ").append(toIndentedString(desiredStatusCode)).append("\n");
    sb.append("    followRedirects: ").append(toIndentedString(followRedirects)).append("\n");
    sb.append("    httpTargetTime: ").append(toIndentedString(httpTargetTime)).append("\n");
    sb.append("    httpTimeLimit: ").append(toIndentedString(httpTimeLimit)).append("\n");
    sb.append("    httpVersion: ").append(toIndentedString(httpVersion)).append("\n");
    sb.append("    includeHeaders: ").append(toIndentedString(includeHeaders)).append("\n");
    sb.append("    mtuMeasurements: ").append(toIndentedString(mtuMeasurements)).append("\n");
    sb.append("    networkMeasurements: ").append(toIndentedString(networkMeasurements)).append("\n");
    sb.append("    numPathTraces: ").append(toIndentedString(numPathTraces)).append("\n");
    sb.append("    password: ").append(toIndentedString(password)).append("\n");
    sb.append("    pathTraceMode: ").append(toIndentedString(pathTraceMode)).append("\n");
    sb.append("    probeMode: ").append(toIndentedString(probeMode)).append("\n");
    sb.append("    protocol: ").append(toIndentedString(protocol)).append("\n");
    sb.append("    sslVersion: ").append(toIndentedString(sslVersion)).append("\n");
    sb.append("    sslVersionId: ").append(toIndentedString(sslVersionId)).append("\n");
    sb.append("    targetTime: ").append(toIndentedString(targetTime)).append("\n");
    sb.append("    timeLimit: ").append(toIndentedString(timeLimit)).append("\n");
    sb.append("    transactionScript: ").append(toIndentedString(transactionScript)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    useNtlm: ").append(toIndentedString(useNtlm)).append("\n");
    sb.append("    userAgent: ").append(toIndentedString(userAgent)).append("\n");
    sb.append("    username: ").append(toIndentedString(username)).append("\n");
    sb.append("    verifyCertificate: ").append(toIndentedString(verifyCertificate)).append("\n");
    sb.append("    blockDomains: ").append(toIndentedString(blockDomains)).append("\n");
    sb.append("    disableScreenshot: ").append(toIndentedString(disableScreenshot)).append("\n");
    sb.append("    allowMicAndCamera: ").append(toIndentedString(allowMicAndCamera)).append("\n");
    sb.append("    allowGeolocation: ").append(toIndentedString(allowGeolocation)).append("\n");
    sb.append("    browserLanguage: ").append(toIndentedString(browserLanguage)).append("\n");
    sb.append("    pageLoadingStrategy: ").append(toIndentedString(pageLoadingStrategy)).append("\n");
    sb.append("    fixedPacketRate: ").append(toIndentedString(fixedPacketRate)).append("\n");
    sb.append("    bgpMeasurements: ").append(toIndentedString(bgpMeasurements)).append("\n");
    sb.append("    monitors: ").append(toIndentedString(monitors)).append("\n");
    sb.append("    subinterval: ").append(toIndentedString(subinterval)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("interval");
    openapiFields.add("alertsEnabled");
    openapiFields.add("enabled");
    openapiFields.add("alertRules");
    openapiFields.add("createdBy");
    openapiFields.add("createdDate");
    openapiFields.add("description");
    openapiFields.add("liveShare");
    openapiFields.add("modifiedBy");
    openapiFields.add("modifiedDate");
    openapiFields.add("savedEvent");
    openapiFields.add("testId");
    openapiFields.add("testName");
    openapiFields.add("type");
    openapiFields.add("_links");
    openapiFields.add("labels");
    openapiFields.add("sharedWithAccounts");
    openapiFields.add("agents");
    openapiFields.add("authType");
    openapiFields.add("bandwidthMeasurements");
    openapiFields.add("clientCertificate");
    openapiFields.add("contentRegex");
    openapiFields.add("credentials");
    openapiFields.add("customHeaders");
    openapiFields.add("desiredStatusCode");
    openapiFields.add("followRedirects");
    openapiFields.add("httpTargetTime");
    openapiFields.add("httpTimeLimit");
    openapiFields.add("httpVersion");
    openapiFields.add("includeHeaders");
    openapiFields.add("mtuMeasurements");
    openapiFields.add("networkMeasurements");
    openapiFields.add("numPathTraces");
    openapiFields.add("password");
    openapiFields.add("pathTraceMode");
    openapiFields.add("probeMode");
    openapiFields.add("protocol");
    openapiFields.add("sslVersion");
    openapiFields.add("sslVersionId");
    openapiFields.add("targetTime");
    openapiFields.add("timeLimit");
    openapiFields.add("transactionScript");
    openapiFields.add("url");
    openapiFields.add("useNtlm");
    openapiFields.add("userAgent");
    openapiFields.add("username");
    openapiFields.add("verifyCertificate");
    openapiFields.add("blockDomains");
    openapiFields.add("disableScreenshot");
    openapiFields.add("allowMicAndCamera");
    openapiFields.add("allowGeolocation");
    openapiFields.add("browserLanguage");
    openapiFields.add("pageLoadingStrategy");
    openapiFields.add("fixedPacketRate");
    openapiFields.add("bgpMeasurements");
    openapiFields.add("monitors");
    openapiFields.add("subinterval");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("interval");
    openapiRequiredFields.add("agents");
    openapiRequiredFields.add("transactionScript");
    openapiRequiredFields.add("url");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to WebTransactionTest
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!WebTransactionTest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in WebTransactionTest is not found in the empty JSON string", WebTransactionTest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!WebTransactionTest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `WebTransactionTest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : WebTransactionTest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("alertRules") != null && !jsonObj.get("alertRules").isJsonNull()) {
        JsonArray jsonArrayalertRules = jsonObj.getAsJsonArray("alertRules");
        if (jsonArrayalertRules != null) {
          // ensure the json data is an array
          if (!jsonObj.get("alertRules").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `alertRules` to be an array in the JSON string but got `%s`", jsonObj.get("alertRules").toString()));
          }

          // validate the optional field `alertRules` (array)
          for (int i = 0; i < jsonArrayalertRules.size(); i++) {
            AlertRule.validateJsonElement(jsonArrayalertRules.get(i));
          };
        }
      }
      if ((jsonObj.get("createdBy") != null && !jsonObj.get("createdBy").isJsonNull()) && !jsonObj.get("createdBy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createdBy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createdBy").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("modifiedBy") != null && !jsonObj.get("modifiedBy").isJsonNull()) && !jsonObj.get("modifiedBy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `modifiedBy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("modifiedBy").toString()));
      }
      if ((jsonObj.get("testId") != null && !jsonObj.get("testId").isJsonNull()) && !jsonObj.get("testId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `testId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("testId").toString()));
      }
      if ((jsonObj.get("testName") != null && !jsonObj.get("testName").isJsonNull()) && !jsonObj.get("testName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `testName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("testName").toString()));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      // validate the optional field `_links`
      if (jsonObj.get("_links") != null && !jsonObj.get("_links").isJsonNull()) {
        UnexpandedInstantTestLinks.validateJsonElement(jsonObj.get("_links"));
      }
      if (jsonObj.get("labels") != null && !jsonObj.get("labels").isJsonNull()) {
        JsonArray jsonArraylabels = jsonObj.getAsJsonArray("labels");
        if (jsonArraylabels != null) {
          // ensure the json data is an array
          if (!jsonObj.get("labels").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `labels` to be an array in the JSON string but got `%s`", jsonObj.get("labels").toString()));
          }

          // validate the optional field `labels` (array)
          for (int i = 0; i < jsonArraylabels.size(); i++) {
            TestLabelsInner.validateJsonElement(jsonArraylabels.get(i));
          };
        }
      }
      if (jsonObj.get("sharedWithAccounts") != null && !jsonObj.get("sharedWithAccounts").isJsonNull()) {
        JsonArray jsonArraysharedWithAccounts = jsonObj.getAsJsonArray("sharedWithAccounts");
        if (jsonArraysharedWithAccounts != null) {
          // ensure the json data is an array
          if (!jsonObj.get("sharedWithAccounts").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `sharedWithAccounts` to be an array in the JSON string but got `%s`", jsonObj.get("sharedWithAccounts").toString()));
          }

          // validate the optional field `sharedWithAccounts` (array)
          for (int i = 0; i < jsonArraysharedWithAccounts.size(); i++) {
            TestSharedAccountsInner.validateJsonElement(jsonArraysharedWithAccounts.get(i));
          };
        }
      }
      // ensure the json data is an array
      if (!jsonObj.get("agents").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `agents` to be an array in the JSON string but got `%s`", jsonObj.get("agents").toString()));
      }

      JsonArray jsonArrayagents = jsonObj.getAsJsonArray("agents");
      // validate the required field `agents` (array)
      for (int i = 0; i < jsonArrayagents.size(); i++) {
        Agent.validateJsonElement(jsonArrayagents.get(i));
      };
      if ((jsonObj.get("clientCertificate") != null && !jsonObj.get("clientCertificate").isJsonNull()) && !jsonObj.get("clientCertificate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `clientCertificate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("clientCertificate").toString()));
      }
      if ((jsonObj.get("contentRegex") != null && !jsonObj.get("contentRegex").isJsonNull()) && !jsonObj.get("contentRegex").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `contentRegex` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contentRegex").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("credentials") != null && !jsonObj.get("credentials").isJsonNull() && !jsonObj.get("credentials").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `credentials` to be an array in the JSON string but got `%s`", jsonObj.get("credentials").toString()));
      }
      // validate the optional field `customHeaders`
      if (jsonObj.get("customHeaders") != null && !jsonObj.get("customHeaders").isJsonNull()) {
        TestCustomHeaders.validateJsonElement(jsonObj.get("customHeaders"));
      }
      if ((jsonObj.get("desiredStatusCode") != null && !jsonObj.get("desiredStatusCode").isJsonNull()) && !jsonObj.get("desiredStatusCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `desiredStatusCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("desiredStatusCode").toString()));
      }
      if ((jsonObj.get("password") != null && !jsonObj.get("password").isJsonNull()) && !jsonObj.get("password").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `password` to be a primitive type in the JSON string but got `%s`", jsonObj.get("password").toString()));
      }
      if ((jsonObj.get("sslVersion") != null && !jsonObj.get("sslVersion").isJsonNull()) && !jsonObj.get("sslVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sslVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sslVersion").toString()));
      }
      if (!jsonObj.get("transactionScript").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `transactionScript` to be a primitive type in the JSON string but got `%s`", jsonObj.get("transactionScript").toString()));
      }
      if (!jsonObj.get("url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("url").toString()));
      }
      if ((jsonObj.get("userAgent") != null && !jsonObj.get("userAgent").isJsonNull()) && !jsonObj.get("userAgent").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `userAgent` to be a primitive type in the JSON string but got `%s`", jsonObj.get("userAgent").toString()));
      }
      if ((jsonObj.get("username") != null && !jsonObj.get("username").isJsonNull()) && !jsonObj.get("username").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `username` to be a primitive type in the JSON string but got `%s`", jsonObj.get("username").toString()));
      }
      if ((jsonObj.get("blockDomains") != null && !jsonObj.get("blockDomains").isJsonNull()) && !jsonObj.get("blockDomains").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `blockDomains` to be a primitive type in the JSON string but got `%s`", jsonObj.get("blockDomains").toString()));
      }
      if ((jsonObj.get("browserLanguage") != null && !jsonObj.get("browserLanguage").isJsonNull()) && !jsonObj.get("browserLanguage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `browserLanguage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("browserLanguage").toString()));
      }
      if (jsonObj.get("monitors") != null && !jsonObj.get("monitors").isJsonNull()) {
        JsonArray jsonArraymonitors = jsonObj.getAsJsonArray("monitors");
        if (jsonArraymonitors != null) {
          // ensure the json data is an array
          if (!jsonObj.get("monitors").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `monitors` to be an array in the JSON string but got `%s`", jsonObj.get("monitors").toString()));
          }

          // validate the optional field `monitors` (array)
          for (int i = 0; i < jsonArraymonitors.size(); i++) {
            Monitor.validateJsonElement(jsonArraymonitors.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!WebTransactionTest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'WebTransactionTest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<WebTransactionTest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(WebTransactionTest.class));

       return (TypeAdapter<T>) new TypeAdapter<WebTransactionTest>() {
           @Override
           public void write(JsonWriter out, WebTransactionTest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public WebTransactionTest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of WebTransactionTest given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of WebTransactionTest
  * @throws IOException if the JSON string is invalid with respect to WebTransactionTest
  */
  public static WebTransactionTest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, WebTransactionTest.class);
  }

 /**
  * Convert an instance of WebTransactionTest to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}


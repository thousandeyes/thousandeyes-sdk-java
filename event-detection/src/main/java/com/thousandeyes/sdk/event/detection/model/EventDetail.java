/*
 * Event Detection API
 *  Event detection occurs when ThousandEyes identifies that error signals related to a component (proxy, network node, AS, server etc) have deviated from the baselines established by events. * To determine this, ThousandEyes takes the test results from all accounts groups within an organization, and analyzes that data. * Noisy test results (those that have too many errors in a short window) are removed until they stabilize, and the rest of the results are tagged with the components associated with that test result (for example, proxy, network, or server). * Next, any increase in failures from the test results and each component helps in determining the problem domain and which component may be at fault. * When this failure rate increases beyond a pre-defined threshold (set by the algorithm), an event is triggered and an email notification is sent to the user (if they've enabled email alerts).  With the Events API, you can perform the following tasks on the ThousandEyes platform: * **Retrieve Events**: Obtain a list of events and detailed information for each event. For more information about events, see [Event Detection](https://docs.thousandeyes.com/product-documentation/event-detection). 
 *
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.thousandeyes.sdk.event.detection.model;

import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.thousandeyes.sdk.event.detection.model.AffectedAgents;
import com.thousandeyes.sdk.event.detection.model.AffectedTargets;
import com.thousandeyes.sdk.event.detection.model.AffectedTests;
import com.thousandeyes.sdk.event.detection.model.AgentLocalEventDetail;
import com.thousandeyes.sdk.event.detection.model.DnsEventDetail;
import com.thousandeyes.sdk.event.detection.model.EventAlertSeverity;
import com.thousandeyes.sdk.event.detection.model.EventState;
import com.thousandeyes.sdk.event.detection.model.NetworkEventDetail;
import com.thousandeyes.sdk.event.detection.model.NetworkEventGrouping;
import com.thousandeyes.sdk.event.detection.model.NetworkPopEventDetail;
import com.thousandeyes.sdk.event.detection.model.ProxyEventDetail;
import com.thousandeyes.sdk.event.detection.model.SelfLinks;
import com.thousandeyes.sdk.event.detection.model.TargetEventDetail;
import com.thousandeyes.sdk.event.detection.model.TargetNetworkEventDetail;
import java.time.OffsetDateTime;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.UUID;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import com.fasterxml.jackson.core.type.TypeReference;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import com.thousandeyes.sdk.serialization.JSON;
import com.thousandeyes.sdk.serialization.AbstractOpenApiSchema;

@jakarta.annotation.Generated(value = "com.thousandeyes.api.codegen.ThousandeyesJavaGenerator")
@JsonDeserialize(using = EventDetail.EventDetailDeserializer.class)
@JsonSerialize(using = EventDetail.EventDetailSerializer.class)
public class EventDetail extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(EventDetail.class.getName());

    public static class EventDetailSerializer extends StdSerializer<EventDetail> {
        public EventDetailSerializer(Class<EventDetail> t) {
            super(t);
        }

        public EventDetailSerializer() {
            this(null);
        }

        @Override
        public void serialize(EventDetail value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
            jgen.writeObject(value.getActualInstance());
        }
    }

    public static class EventDetailDeserializer extends StdDeserializer<EventDetail> {
        public EventDetailDeserializer() {
            this(EventDetail.class);
        }

        public EventDetailDeserializer(Class<?> vc) {
            super(vc);
        }

        @Override
        public EventDetail deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {
            JsonNode tree = jp.readValueAsTree();
            Object deserialized = null;
            EventDetail newEventDetail = new EventDetail();
            Map<String,Object> result2 = tree.traverse(jp.getCodec()).readValueAs(new TypeReference<Map<String, Object>>() {});
            String discriminatorValue = (String)result2.get("type");
            switch (discriminatorValue) {
                case "agent-local":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(AgentLocalEventDetail.class);
                    newEventDetail.setActualInstance(deserialized);
                    return newEventDetail;
                case "dns":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DnsEventDetail.class);
                    newEventDetail.setActualInstance(deserialized);
                    return newEventDetail;
                case "network":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(NetworkEventDetail.class);
                    newEventDetail.setActualInstance(deserialized);
                    return newEventDetail;
                case "network-pop":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(NetworkPopEventDetail.class);
                    newEventDetail.setActualInstance(deserialized);
                    return newEventDetail;
                case "proxy":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ProxyEventDetail.class);
                    newEventDetail.setActualInstance(deserialized);
                    return newEventDetail;
                case "target":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(TargetEventDetail.class);
                    newEventDetail.setActualInstance(deserialized);
                    return newEventDetail;
                case "target-network":
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(TargetNetworkEventDetail.class);
                    newEventDetail.setActualInstance(deserialized);
                    return newEventDetail;
                default:
                    log.log(Level.WARNING, String.format("Failed to lookup discriminator value `%s` for EventDetail. Possible values: agent-local dns network network-pop proxy target target-network", discriminatorValue));
            }

            boolean typeCoercion = ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS);
            int match = 0;
            JsonToken token = tree.traverse(jp.getCodec()).nextToken();
            // deserialize AgentLocalEventDetail
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (AgentLocalEventDetail.class.equals(Integer.class) || AgentLocalEventDetail.class.equals(Long.class) || AgentLocalEventDetail.class.equals(Float.class) || AgentLocalEventDetail.class.equals(Double.class) || AgentLocalEventDetail.class.equals(Boolean.class) || AgentLocalEventDetail.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((AgentLocalEventDetail.class.equals(Integer.class) || AgentLocalEventDetail.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((AgentLocalEventDetail.class.equals(Float.class) || AgentLocalEventDetail.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (AgentLocalEventDetail.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (AgentLocalEventDetail.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(AgentLocalEventDetail.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'AgentLocalEventDetail'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'AgentLocalEventDetail'", e);
            }

            // deserialize DnsEventDetail
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (DnsEventDetail.class.equals(Integer.class) || DnsEventDetail.class.equals(Long.class) || DnsEventDetail.class.equals(Float.class) || DnsEventDetail.class.equals(Double.class) || DnsEventDetail.class.equals(Boolean.class) || DnsEventDetail.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((DnsEventDetail.class.equals(Integer.class) || DnsEventDetail.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((DnsEventDetail.class.equals(Float.class) || DnsEventDetail.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (DnsEventDetail.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (DnsEventDetail.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(DnsEventDetail.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'DnsEventDetail'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'DnsEventDetail'", e);
            }

            // deserialize NetworkEventDetail
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (NetworkEventDetail.class.equals(Integer.class) || NetworkEventDetail.class.equals(Long.class) || NetworkEventDetail.class.equals(Float.class) || NetworkEventDetail.class.equals(Double.class) || NetworkEventDetail.class.equals(Boolean.class) || NetworkEventDetail.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((NetworkEventDetail.class.equals(Integer.class) || NetworkEventDetail.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((NetworkEventDetail.class.equals(Float.class) || NetworkEventDetail.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (NetworkEventDetail.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (NetworkEventDetail.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(NetworkEventDetail.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'NetworkEventDetail'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'NetworkEventDetail'", e);
            }

            // deserialize NetworkPopEventDetail
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (NetworkPopEventDetail.class.equals(Integer.class) || NetworkPopEventDetail.class.equals(Long.class) || NetworkPopEventDetail.class.equals(Float.class) || NetworkPopEventDetail.class.equals(Double.class) || NetworkPopEventDetail.class.equals(Boolean.class) || NetworkPopEventDetail.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((NetworkPopEventDetail.class.equals(Integer.class) || NetworkPopEventDetail.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((NetworkPopEventDetail.class.equals(Float.class) || NetworkPopEventDetail.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (NetworkPopEventDetail.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (NetworkPopEventDetail.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(NetworkPopEventDetail.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'NetworkPopEventDetail'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'NetworkPopEventDetail'", e);
            }

            // deserialize ProxyEventDetail
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ProxyEventDetail.class.equals(Integer.class) || ProxyEventDetail.class.equals(Long.class) || ProxyEventDetail.class.equals(Float.class) || ProxyEventDetail.class.equals(Double.class) || ProxyEventDetail.class.equals(Boolean.class) || ProxyEventDetail.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ProxyEventDetail.class.equals(Integer.class) || ProxyEventDetail.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ProxyEventDetail.class.equals(Float.class) || ProxyEventDetail.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ProxyEventDetail.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ProxyEventDetail.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ProxyEventDetail.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ProxyEventDetail'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ProxyEventDetail'", e);
            }

            // deserialize TargetEventDetail
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (TargetEventDetail.class.equals(Integer.class) || TargetEventDetail.class.equals(Long.class) || TargetEventDetail.class.equals(Float.class) || TargetEventDetail.class.equals(Double.class) || TargetEventDetail.class.equals(Boolean.class) || TargetEventDetail.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((TargetEventDetail.class.equals(Integer.class) || TargetEventDetail.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((TargetEventDetail.class.equals(Float.class) || TargetEventDetail.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (TargetEventDetail.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (TargetEventDetail.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(TargetEventDetail.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'TargetEventDetail'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'TargetEventDetail'", e);
            }

            // deserialize TargetNetworkEventDetail
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (TargetNetworkEventDetail.class.equals(Integer.class) || TargetNetworkEventDetail.class.equals(Long.class) || TargetNetworkEventDetail.class.equals(Float.class) || TargetNetworkEventDetail.class.equals(Double.class) || TargetNetworkEventDetail.class.equals(Boolean.class) || TargetNetworkEventDetail.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((TargetNetworkEventDetail.class.equals(Integer.class) || TargetNetworkEventDetail.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((TargetNetworkEventDetail.class.equals(Float.class) || TargetNetworkEventDetail.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (TargetNetworkEventDetail.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (TargetNetworkEventDetail.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(TargetNetworkEventDetail.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'TargetNetworkEventDetail'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'TargetNetworkEventDetail'", e);
            }

            if (match == 1) {
                EventDetail ret = new EventDetail();
                ret.setActualInstance(deserialized);
                return ret;
            }
            throw new IOException(String.format("Failed deserialization for EventDetail: %d classes match result, expected 1", match));
        }

        /**
         * Handle deserialization of the 'null' value.
         */
        @Override
        public EventDetail getNullValue(DeserializationContext ctxt) throws JsonMappingException {
            throw new JsonMappingException(ctxt.getParser(), "EventDetail cannot be null");
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, Class<?>> schemas = new HashMap<>();

    public EventDetail() {
        super("oneOf", Boolean.FALSE);
    }

    public EventDetail(AgentLocalEventDetail o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EventDetail(DnsEventDetail o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EventDetail(NetworkEventDetail o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EventDetail(NetworkPopEventDetail o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EventDetail(ProxyEventDetail o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EventDetail(TargetEventDetail o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public EventDetail(TargetNetworkEventDetail o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("AgentLocalEventDetail", AgentLocalEventDetail.class);
        schemas.put("DnsEventDetail", DnsEventDetail.class);
        schemas.put("NetworkEventDetail", NetworkEventDetail.class);
        schemas.put("NetworkPopEventDetail", NetworkPopEventDetail.class);
        schemas.put("ProxyEventDetail", ProxyEventDetail.class);
        schemas.put("TargetEventDetail", TargetEventDetail.class);
        schemas.put("TargetNetworkEventDetail", TargetNetworkEventDetail.class);
        JSON.registerDescendants(EventDetail.class, Collections.unmodifiableMap(schemas));
        // Initialize and register the discriminator mappings.
        Map<String, Class<?>> mappings = new HashMap<String, Class<?>>();
        mappings.put("agent-local", AgentLocalEventDetail.class);
        mappings.put("dns", DnsEventDetail.class);
        mappings.put("network", NetworkEventDetail.class);
        mappings.put("network-pop", NetworkPopEventDetail.class);
        mappings.put("proxy", ProxyEventDetail.class);
        mappings.put("target", TargetEventDetail.class);
        mappings.put("target-network", TargetNetworkEventDetail.class);
        mappings.put("EventDetail", EventDetail.class);
        JSON.registerDiscriminator(EventDetail.class, "type", mappings);
    }

    @Override
    public Map<String, Class<?>> getSchemas() {
        return EventDetail.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * AgentLocalEventDetail, DnsEventDetail, NetworkEventDetail, NetworkPopEventDetail, ProxyEventDetail, TargetEventDetail, TargetNetworkEventDetail
     *
     * It could be an instance of the 'oneOf' schemas.
     * The oneOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (JSON.isInstanceOf(AgentLocalEventDetail.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(DnsEventDetail.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(NetworkEventDetail.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(NetworkPopEventDetail.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ProxyEventDetail.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(TargetEventDetail.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(TargetNetworkEventDetail.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be AgentLocalEventDetail, DnsEventDetail, NetworkEventDetail, NetworkPopEventDetail, ProxyEventDetail, TargetEventDetail, TargetNetworkEventDetail");
    }

    /**
     * Get the actual instance, which can be the following:
     * AgentLocalEventDetail, DnsEventDetail, NetworkEventDetail, NetworkPopEventDetail, ProxyEventDetail, TargetEventDetail, TargetNetworkEventDetail
     *
     * @return The actual instance (AgentLocalEventDetail, DnsEventDetail, NetworkEventDetail, NetworkPopEventDetail, ProxyEventDetail, TargetEventDetail, TargetNetworkEventDetail)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `AgentLocalEventDetail`. If the actual instance is not `AgentLocalEventDetail`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `AgentLocalEventDetail`
     * @throws ClassCastException if the instance is not `AgentLocalEventDetail`
     */
    public AgentLocalEventDetail getAgentLocalEventDetail() throws ClassCastException {
        return (AgentLocalEventDetail)super.getActualInstance();
    }

    /**
     * Get the actual instance of `DnsEventDetail`. If the actual instance is not `DnsEventDetail`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DnsEventDetail`
     * @throws ClassCastException if the instance is not `DnsEventDetail`
     */
    public DnsEventDetail getDnsEventDetail() throws ClassCastException {
        return (DnsEventDetail)super.getActualInstance();
    }

    /**
     * Get the actual instance of `NetworkEventDetail`. If the actual instance is not `NetworkEventDetail`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `NetworkEventDetail`
     * @throws ClassCastException if the instance is not `NetworkEventDetail`
     */
    public NetworkEventDetail getNetworkEventDetail() throws ClassCastException {
        return (NetworkEventDetail)super.getActualInstance();
    }

    /**
     * Get the actual instance of `NetworkPopEventDetail`. If the actual instance is not `NetworkPopEventDetail`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `NetworkPopEventDetail`
     * @throws ClassCastException if the instance is not `NetworkPopEventDetail`
     */
    public NetworkPopEventDetail getNetworkPopEventDetail() throws ClassCastException {
        return (NetworkPopEventDetail)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ProxyEventDetail`. If the actual instance is not `ProxyEventDetail`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ProxyEventDetail`
     * @throws ClassCastException if the instance is not `ProxyEventDetail`
     */
    public ProxyEventDetail getProxyEventDetail() throws ClassCastException {
        return (ProxyEventDetail)super.getActualInstance();
    }

    /**
     * Get the actual instance of `TargetEventDetail`. If the actual instance is not `TargetEventDetail`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `TargetEventDetail`
     * @throws ClassCastException if the instance is not `TargetEventDetail`
     */
    public TargetEventDetail getTargetEventDetail() throws ClassCastException {
        return (TargetEventDetail)super.getActualInstance();
    }

    /**
     * Get the actual instance of `TargetNetworkEventDetail`. If the actual instance is not `TargetNetworkEventDetail`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `TargetNetworkEventDetail`
     * @throws ClassCastException if the instance is not `TargetNetworkEventDetail`
     */
    public TargetNetworkEventDetail getTargetNetworkEventDetail() throws ClassCastException {
        return (TargetNetworkEventDetail)super.getActualInstance();
    }



}

